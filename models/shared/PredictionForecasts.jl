module PredictionForecasts

# Create a bunch of Forecast structs whose data is the
# predictions generated by some prediction model applied
# to an existing base forecast (e.g. HREF).
#
# get_feature_engineered_data will use the underlying winds to
# generate the spatial means and gradients of the probability.

import MemoryConstrainedTreeBoosting

push!(LOAD_PATH, (@__DIR__) * "/../../lib")

import Forecasts
import Grids
import Inventories
import ForecastCombinators

push!(LOAD_PATH, (@__DIR__) * "/../shared")
import FeatureEngineeringShared

function weighted_prediction_between_models_at_different_forecast_hours(forecast, data, low_hour, high_hour, low_hour_predict, high_hour_predict)
  high_weight = ((forecast.forecast_hour-low_hour) / Float32(high_hour - low_hour)) :: Float32
  (1 - high_weight) .* low_hour_predict(data) .+ high_weight .* high_hour_predict(data)
end

# combined_sref_href_calibration = [
#   (0.02, 0.016253397),
#   (0.05, 0.0649308),
#   (0.1,  0.18771306),
#   (0.15, 0.28330332),
#   (0.3,  0.32384455),
# ]
function calibrated_forecasts(base_forecasts, calibration; model_name = nothing)

  ratio_between(x, lo, hi) = (x - lo) / (hi - lo)

  calibration = [(0,0); calibration; (1,1)]
  calibs = map(calib -> Float32.(calib), calibration)

  data_transformer(base_forecast, base_data) = begin
    out = Array{Float32}(undef, size(base_data))

    for j in 1:size(base_data,2) # should always only be 1 feature in these forecasts
      Threads.@threads for i in 1:size(base_data,1)
        x        = base_data[i,j]
        for k in 2:length(calibs)
          lo_spc, lo_thres = calibs[k-1]
          hi_spc, hi_thres = calibs[k]
          if x < hi_thres || k == length(calibs)
            ratio = ratio_between(x, lo_thres, hi_thres)
            out[i,j] = lo_spc + ratio * (hi_spc - lo_spc)
            break
          end
        end
      end
    end

    out
  end

  ForecastCombinators.map_forecasts(base_forecasts; data_transformer = data_transformer, model_name = model_name)
end


# models is an array of (event_name, var_name, model_predict)
# model_predict takes forecast, data
# output is length(models) features, one for each model
function simple_prediction_forecasts(base_forecasts, models; model_name = nothing)

  inventory_transformer(base_forecast, base_inventory) =
    map(models) do (event_name, var_name, model_predict)
      Inventories.InventoryLine(
        "",                                         # message_dot_submessage :: String # "3" or "3.2"
        "",                                         # position_str           :: String # "956328"
        base_inventory[1].date_str,                 # date_str               :: String # "d=2018062900"
        var_name,                                   # abbrev                 :: String # "CAPE"
        "calculated",                               # level                  :: String # "180-0 mb above ground"
        "$(base_forecast.forecast_hour) hour fcst", # forecast_hour_str      :: String # "7 hour fcst" or "6-hour acc fcst" or "11-12 hour acc fcst" or "11-12 hour ave fcst"  or "11-12 hour max fcst"
        "calculated_prob",                          # misc                   :: String # "wt ens mean" or "prob >2.54"
        ""                                          # feature_engineering    :: String # "" or "25mi mean" or "100mi forward grad" etc
      )
    end

  data_transformer(base_forecast, base_data) = begin
    data_count    = size(base_data, 1)
    feature_count = length(models)
    out = Array{Float32}(undef, (data_count, feature_count))

    for i in 1:length(models)
      event_name, var_name, model_predict = models[i]
      out[:, i] = Float32.(model_predict(base_forecast, base_data))
    end

    out
  end

  ForecastCombinators.map_forecasts(base_forecasts; inventory_transformer = inventory_transformer, data_transformer = data_transformer, model_name = model_name)
end

# Prediction forecast modified with no blur, each of the blur radii, and the forecast hour
# So 1+length(blur_radii)+1 features.
function with_blurs_and_forecast_hour(prediction_forecasts, blur_radii; model_name = nothing)
  grid = prediction_forecasts[1].grid

  blur_radii_grid_is = map(miles -> Grids.radius_grid_is(grid, miles), Float64.(blur_radii))


  inventory_transformer(base_forecast, base_inventory) = begin

    new_inventory = []

    for i in 1:length(base_inventory)
      no_blur_line = base_inventory[i]
      push!(new_inventory, no_blur_line)

      for miles in blur_radii
        push!(new_inventory, Inventories.revise_with_feature_engineering(no_blur_line, "$(miles)mi mean"))
      end
    end

    push!(new_inventory, Inventories.InventoryLine("", "", base_inventory[1].date_str, "forecast_hour", "calculated", "hour fcst", "", ""))

    new_inventory
  end

  data_transformer(base_forecast, base_data) = begin
    point_count, prediction_count = size(base_data)

    out_feature_count = (1 + length(blur_radii)) * prediction_count + 1

    out = Array{Float32}(undef, (point_count, out_feature_count))

    out_feature_i = 0

    for prediction_i in 1:prediction_count
      no_blur_data = @view base_data[:, prediction_i]

      out_feature_i += 1
      out[:, out_feature_i] = no_blur_data

      for blur_i in 1:length(blur_radii)
        out_feature_i += 1
        out[:, out_feature_i] = FeatureEngineeringShared.meanify_threaded(no_blur_data, blur_radii_grid_is[blur_i])
      end
    end

    out_feature_i += 1
    out[:, out_feature_i] .= Float32(base_forecast.forecast_hour)

    @assert out_feature_i == out_feature_count

    out
  end

  ForecastCombinators.map_forecasts(prediction_forecasts; inventory_transformer = inventory_transformer, data_transformer = data_transformer, model_name = model_name)
end

# Prediction forecast blurred based on forecast hour.
# Linear combination of the two blur results s.t. at the near (lo) forecast hour only the first blur is used and
# at the far (hi) forecast hour, only the second blur is used.
# 1 resulting features: blurred result
function blurred(prediction_forecasts, forecast_hour_range, blur_lo_grid_is, blur_hi_grid_is; model_name = nothing)

  inventory_transformer(base_forecast, base_inventory) =
    map(base_inventory) do no_blur_line
      Inventories.revise_with_feature_engineering(no_blur_line, "blurred")
    end

  data_transformer(base_forecast, base_data) = begin
    point_count, prediction_count = size(base_data)

    out = Array{Float32}(undef, (point_count, prediction_count))

    for prediction_i in 1:prediction_count
      no_blur_data = @view base_data[:, prediction_i]
      blur_lo_data = FeatureEngineeringShared.meanify_threaded(no_blur_data, blur_lo_grid_is)
      blur_hi_data = FeatureEngineeringShared.meanify_threaded(no_blur_data, blur_hi_grid_is)

      forecast_hour = Float32(base_forecast.forecast_hour)
      lo_hour = Float32(forecast_hour_range.start)
      hi_hour = Float32(forecast_hour_range.stop)
      forecast_ratio = (forecast_hour - lo_hour) * (1f0/(hi_hour-lo_hour))
      one_minus_forecast_ratio = 1f0 - forecast_ratio

      Threads.@threads for i in 1:point_count
        out[i, prediction_i] = blur_lo_data[i] * one_minus_forecast_ratio + blur_hi_data[i] * forecast_ratio
      end
    end

    out
  end

  ForecastCombinators.map_forecasts(prediction_forecasts; inventory_transformer = inventory_transformer, data_transformer = data_transformer, model_name = model_name)
end


end # module PredictionForecasts
